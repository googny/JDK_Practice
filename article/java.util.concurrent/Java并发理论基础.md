# 并发理论基础 #
*以下观点来自于《Java程序员修炼之道》，而且我深表同意，在此记录*
## Java线程模型 ##
Java线程模型建立在两个**基本概念**之上：
> 共享的、默认可见的可变状态（可变对象的状态呗）  
> 抢占式线程调度

思考这两个概念：  

- 所有线程都可以很容易的共享同一个进程中的对象。  
- 能够引用这些对象的线程，都可以改变这些对象的状态。  
- 线程调度程序在任何时候都能够在CPU核心上调入或调出线程。  
- 必须能调出运行时的方法，否则无限循环的方法会一直占据CPU。  
- 为了保护脆弱的数据，对象可以被锁住。

###**并发OO系统实际设计中的指导性原则（经常相互冲突）**  

- 安全性（并发类型安全性）  
- 活跃度  
- 性能  
- 重用性  

### 1、安全性与并发类型安全性 ###
安全性是指不管同时发生多少操作都能确保对象保持自相一致。如果一个对象系统具备这一特性，那它就是**并发类型安全**的。  
通常用来达成这一点的做法是保证对象所有状态都私有，并且开放出来的公开API方法只能以自相一致的方式修改对象状态。  
保证安全的策略之一是**对象在处于非一致状态时决不能从非私有方法中返回，也绝不能调用任何非私有方法，而且也绝不能调用其他任何对象中的方法。+_+**  
### 2、活跃度 ###
在一个活跃的系统中，所有做出的尝试的活动**最终**或者取得进展，或者失败。（好有道理）  
请注意**最终**二字，运行中的**瞬时故障**和**永久故障**是不同的。  
以下几种底层问题可能会导致系统出现瞬时故障：  

- 处于锁定状态或者等待得到线程锁  
- 等待IO  
- 资源的暂时故障  
- CPU没有足够的空闲时间运行该线程

导致系统出现永久故障的常见原因是：  

- 死锁  
- 不可恢复的资源问题  
- 信号丢失  

### 3、性能 ###
系统性能可通过几种不同的方式量化。  

### 4、可重用性 ###
使用可重用集合（java.util.concurrent 包），并把不可重用的应用代码构建在工具集之上是一种可行的办法。  

### 这些原则如何以及为何会相互冲突
说说我自己的理解：  
比如安全性和性能，为了安全性，我们可能会对一个对象的每个方法进行同步，这样能够保证对象的安全，但是往往这样做取得的性能不是特别满意。  
"==========================  

- 安全性和活跃度相互对立 ---安全性是为了确保坏事不会发生，而活跃度要求见到进展  
- 可重用的系统倾向于对外开放其内核，可这会引发安全问题。  
- 一个安全但编写方式幼稚的系统性能通常不会太好，因为里面一般会用大量的锁来保护安全性。  

### 系统开销之源 ###
并发系统中的系统开销是与生俱来的，这些开销来自：  

- 锁与检测  
- 环境切换的次数  
- 线程的个数  
- 调度  
- 内存的局限性  
- 算法设计  

## 同步与锁 ##
关于同步与锁相关的一些基本事实：  

- 只能锁定对象，不能锁定原始类型  
- 被锁定的对象数组中的单个对象不会被锁定  
- 同步方法可以视为包含整个方法的synchronized (this) { ... }代码块  
- 静态同步方法会锁定它的Class对象，因为没有实例对象可以锁定  
- 如果要锁定一个类对象，请慎重考虑使用显式锁定，还是用getClass()，两种方式**对子类的影响不同**  
- 内部类的同步是独立于外部类的  
- synchronized 并不是方法签名的组成部分，所以不能出现在接口的方法声明中  
- 非同步方法不查看也不关心任何锁的状态，而且在同步方法运行时，它们仍能继续运行  
- Java的线程锁是可重入的。也就是说锁可以递归，得到锁的线程可以调用其他相同锁的同步方法和代码块。 

**同步的是什么？**   
被同步的是在不同线程中表示被锁定对象的内存块。也就是说在同步块执行完之后，对被锁定对象所做的任何修改全部都会在线程锁释放之前刷回到主内存中。  

##线程的状态模型
就绪  运行  阻塞 死亡 睡眠  等待 这么多状态

等待IO或同步阻塞的线程并没有被交换出CPU核心，而是仍然处于繁忙状态，等着获取可用的锁或数据。  

### 完全同步对象 ###
当一个类遵从下面所有规则，就可以认为它是线程安全并且活跃的。  
一个满足下面所有条件的类就是完全同步类  

- 所有域在任何构造方法中都能得到一致的状态  
- 没有公共域  
- 从任何非私有方法返回后，都可以保证对象实例处于一致的状态（调用前状态也是一致的）  
- 所有方法经证明都可在有限时间内终止（没有死循环）  
- 所有方法都是同步的  
- 当处于非一致状态时，不会调用其他实例的方法  
- 当处于非一致状态时，不会调用非私有方法  

然而，这样的类的性能是不高的。  

### 死锁 ###
死锁产生的原因已经很清楚了，相互竞争对方占用的锁。  
避免死锁的一个小技巧：  
就是所有线程中都以相同的顺序获取线程锁。  

### volatile关键字 ###
是一种简单的对象域同步处理方法，包括原始类型。  

- 线程所见的值在使用之前总会从主内存中再读出来。  
- 线程所写的值总会在指令完成之前被刷回到内存中。  

volatile 变量不会引入线程锁，因此使用volatile不可能发生死锁。  
只有当写入时不依赖当前状态（读取状态）的变量才应该被声明为volatile变量（i++则不行，）。对于要关注当前状态的变量，只能借助线程锁保证其绝对安全性。