# 并发理论基础 #
*以下观点来自于《Java程序员修炼之道》，而且我深表同意，在此记录*
## Java线程模型 ##
Java线程模型建立在两个**基本概念**之上：
> 共享的、默认可见的可变状态（可变对象的状态呗）  
> 抢占式线程调度

思考这两个概念：  

- 所有线程都可以很容易的共享同一个进程中的对象。  
- 能够引用这些对象的线程，都可以改变这些对象的状态。  
- 线程调度程序在任何时候都能够在CPU核心上调入或调出线程。  
- 必须能调出运行时的方法，否则无限循环的方法会一直占据CPU。  
- 为了保护脆弱的数据，对象可以被锁住。

###**并发OO系统实际设计中的指导性原则（经常相互冲突）**  

- 安全性（并发类型安全性）  
- 活跃度  
- 性能  
- 重用性  

### 1、安全性与并发类型安全性 ###
安全性是指不管同时发生多少操作都能确保对象保持自相一致。如果一个对象系统具备这一特性，那它就是**并发类型安全**的。  
通常用来达成这一点的做法是保证对象所有状态都私有，并且开放出来的公开API方法只能以自相一致的方式修改对象状态。  
保证安全的策略之一是**对象在处于非一致状态时决不能从非私有方法中返回，也绝不能调用任何非私有方法，而且也绝不能调用其他任何对象中的方法。+_+**  
### 2、活跃度 ###
在一个活跃的系统中，所有做出的尝试的活动**最终**或者取得进展，或者失败。（好有道理）  
请注意**最终**二字，运行中的**瞬时故障**和**永久故障**是不同的。  
以下几种底层问题可能会导致系统出现瞬时故障：  

- 处于锁定状态或者等待得到线程锁  
- 等待IO  
- 资源的暂时故障  
- CPU没有足够的空闲时间运行该线程

导致系统出现永久故障的常见原因是：  

- 死锁  
- 不可恢复的资源问题  
- 信号丢失  

### 3、性能 ###
系统性能可通过几种不同的方式量化。  

### 4、可重用性 ###
使用可重用集合（java.util.concurrent 包），并把不可重用的应用代码构建在工具集之上是一种可行的办法。  

### 这些原则如何以及为何会相互冲突
说说我自己的理解：  
比如安全性和性能，为了安全性，我们可能会对一个对象的每个方法进行同步，这样能够保证对象的安全，但是往往这样做取得的性能不是特别满意。  
"==========================  

- 安全性和活跃度相互对立 ---安全性是为了确保坏事不会发生，而活跃度要求见到进展  
- 可重用的系统倾向于对外开放其内核，可这会引发安全问题。  
- 一个安全但编写方式幼稚的系统性能通常不会太好，因为里面一般会用大量的锁来保护安全性。  

### 系统开销之源 ###
并发系统中的系统开销是与生俱来的，这些开销来自：  

- 锁与检测  
- 环境切换的次数  
- 线程的个数  
- 调度  
- 内存的局限性  
- 算法设计  